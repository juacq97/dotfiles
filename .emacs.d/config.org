#+TITLE: Emacs configuration
 I think it's done. The entire configuration, migraated. Time to try it.

* About this file
This is my own Emacs configuration. I started to use emacs on september of 2018, and I can't remember how many times I have re-written this file. This is the first time I try to write it entirely in english, so expect typos. I'm not a lisp master, I even doesn't understand a lot of this file entirely, so maybe there's a lot better way to do some things. A lot of code was copied from internet and I can't remember where now. I'll change this notice in the future, once this file is completed. I don't expect someone interested in it though.

This is an ~org-mode~ file, so you can read it directly from emacs.

* Basic configurations
This include a lot of configurations so Emacs doesn't look like a very ugly notepad. 
#+begin_src emacs-lisp
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (menu-bar-mode -1)
  (global-set-key (kbd "M-m") 'menu-bar-mode) ; Opens the menu with M-m, very KDE-ish
  ;; The modeline shows the column number
  (column-number-mode 1)
  ;; Enable line numbers at the left. Relative shows the numbers relative to the focused one
  (global-display-line-numbers-mode)
  (setq display-line-numbers-type 'relative)
  ;; Match parenthesis
  (show-paren-mode t)
  ;; Disable the blinking
  (blink-cursor-mode 0)
#+end_src

Here's some QOL configurations
#+begin_src emacs-lisp
  ;; Press y/n instead of the whole word
  (defalias 'yes-or-no-p 'y-or-n-p)
  ;; Scroll line by line. Cursor doesn't stays at the center of the screen
  (setq scroll-conservatively 100)
  ;; Disable backups. I'm not sure I want this disabled, but opening files it's veeeery slow
  (setq make-backup-files nil) 
  (setq backup-directory-alist
	`((".*" . ,"~/.emacs.d/backups/")))
  (setq auto-save-file-name-transforms
	`((".*" ,"~/.emacs.d/backups/")))
  (setq auto-save-list-file-prefix nil)
  (setq auto-save-default nil)

  ;; This function allows to quicky open this file
  ;; TODO: MOVE THIS TO ANOTHER PLACE
  (defun config-visit ()
    (interactive)
    (find-file "~/.emacs.d/config.org"))
  (global-set-key (kbd "C-c e") 'config-visit)
  
 ;; Updates the config fiel with C-c r
  (defun config-reload ()
    (interactive)
    (org-babel-load-file "~/.repos/dotfiles/.emacs.d/config.org"))
  (global-set-key (kbd "C-c r") 'config-reload)

  ;; The text nevers goes outside from the buffer
  (global-visual-line-mode 1)

  ;; Disables the ugly splash screen and the scratch message.
  (setq inhibit-splash-screen t)
  (setq initial-scratch-message nil)
  ;(setq initial-major-mode (quote org-mode))

  ;; With this, emacs will not ask if I want to edit the symlink every time
  (setq vc-follow-symlinks nil)

  ;; This is necessary on +27 to write accents. They say it's a feature... but for who?
  (require 'iso-transl)
  
#+end_src

* Fonts
Fonts are a ~face~. You can set different faces. I define three kind of fonts here:
- Default: The default font
- fixed-pitch: The monospace font
- Variable-pitch: The "normal" font
  
Since I change fonts very often I put it here, easy to find.
#+begin_src emacs-lisp
  (set-face-attribute 'default nil :font "Inconsolata Nerd Font" :height 110)
  (set-face-attribute 'fixed-pitch nil :font "Inconsolata Nerd Font" :height 110)
  (set-face-attribute 'variable-pitch nil :font "Noto Sans" :height 110 :weight 'regular)
#+end_src

* Evil
Evil it's a layer to use vim-like keybindings on Emacs.It's basically, VIM inside Emacs. There some functions of VIM that doesn't work inside Evil though or it does but different. Evil-mode calls the vim modes "states", because Emacs has his own meaning for the word "mode". 

#+begin_src emacs-lisp
  (use-package evil
    :ensure t
    :init
    ;; This variable has issues with some commands, example, ~vi~ to append text at the beggining of the lines.
    (setq evil-want-keybinding nil)
    :custom
    ;; This variable needs to be setted by ~customize-group RET evil~. That's why use :custom instead of (setq).
    ;; this is needed to the undo feature
    (evil-undo-system 'undo-tree)
    :config
    (setq-default evil-cross-lines t)
    (evil-mode 1))
#+end_src

To undo, ~undo-tree~ is needed.
#+begin_src emacs-lisp
  (use-package undo-tree
    :ensure t
    :config
  (global-undo-tree-mode 1))
#+end_src

** Evil collection and friends
Evil does works fine with text, but some modes has special keybindings or are interactive buffers, so Evil conflict with them. That's why ~evil-collection~ exists. Basically, it's a collection of key-maps for different modes.
#+begin_src emacs-lisp
  (use-package evil-collection
    :after evil
    :ensure t
    :config
    (evil-collection-init))
#+end_src

There's some modes not supported by ~evil-collection~.
#+begin_src emacs-lisp
  (use-package evil-org
    :ensure t
    :after org
    :hook ((org-mode . evil-org-mode)
	   (evil-org-mode . (lambda ()
			      (evil-org-set-key-theme))))
    :config
    (require 'evil-org-agenda)
    (evil-org-agenda-set-keys)
    ;; This are keybindings for org-agenda
    (evil-define-key 'motion org-agenda-mode-map
      (kbd "C-p") 'org-agenda-earlier
      (kbd "C-n") 'org-agenda-later))
#+end_src

By defaut, evil moves on physical lines instead of visual lines. This is annoying, because most of the time I work with text and ~visual-line-mode~ enabled. This fix it.
#+begin_src emacs-lisp
  (define-key evil-normal-state-map (kbd "<remap> <evil-next-line>") 'evil-next-visual-line)
  (define-key evil-normal-state-map (kbd "<remap> <evil-previous-line>") 'evil-previous-visual-line)
  (define-key evil-motion-state-map (kbd "<remap> <evil-next-line>") 'evil-next-visual-line)
  (define-key evil-motion-state-map (kbd "<remap> <evil-previous-line>") 'evil-previous-visual-line)
  (define-key evil-motion-state-map (kbd "C-u") 'evil-scroll-up)
#+end_src

* Global keybindings
Since ~Evil~ it's working now, this is a good moment to define some personal keybindings. I define it here because some of them needs Evil to work.
#+begin_src emacs-lisp
  (global-set-key (kbd "C-x k") 'kill-current-buffer)
  (global-set-key (kbd "C-c v") 'visual-line-mode)
  (global-set-key (kbd "<f5>")  'ispell-word)
  (define-key evil-normal-state-map (kbd "SPC SPC") 'counsel-find-file)
  (define-key evil-normal-state-map (kbd "SPC k") 'kill-current-buffer)
  (define-key evil-normal-state-map (kbd "SPC b") 'ivy-switch-buffer)
  (define-key evil-normal-state-map (kbd "SPC s") 'swiper)
  (define-key evil-normal-state-map (kbd "SPC p") 'projectile-find-file)
  (define-key evil-normal-state-map (kbd "SPC P") 'projectile-switch-project)
  (define-key evil-normal-state-map (kbd "SPC g") 'magit)
  (define-key evil-normal-state-map (kbd "SPC v") 'visual-line-mode)
  (define-key evil-normal-state-map (kbd "SPC c") 'org-capture)
  (define-key evil-normal-state-map (kbd "SPC RET") (lambda () (interactive) (shell-command "alacritty > /dev/null 2>&1 & disown")))
#+end_src
* Doom-modeline
The default modeline it's fine, but ugly and with a lot of useless information for me. I could customize it, but it's easier to just install ~doom-modeline~ the default modeline of ~doom-emacs~. Most of this is a copy-paste from the official README.
#+begin_src emacs-lisp
  (use-package doom-modeline
    :ensure t
    :hook (after-init . doom-modeline-mode)
    :config
    (setq doom-modeline-height 25)
    (setq doom-modeline-bar-width 4)
    (setq doom-modeline-buffer-file-name-style 'relative-from-project)
    (setq doom-modeline-icon t)
    (setq doom-modeline-major-mode-icon t)
    (setq doom-modeline-modal-icon t)
    (setq doom-modeline-major-mode-color-icon t)
    (setq doom-modeline-minor-modes nil)
    (setq doom-modeline-buffer-encoding nil)
    (setq doom-modeline-enable-word-count t)
    (setq doom-modeline-checker-simple-format t)
    (setq doom-modeline-persp-name t)
    (setq doom-modeline-lsp nil)
    (setq doom-modeline-github t)
    (setq doom-modeline-github-interval (* 30 60))
    (setq doom-modeline-env-version t)
    (setq doom-modeline-env-enable-python t)
    (setq doom-modeline-env-enable-ruby t)
    (setq doom-modeline-env-enable-perl t)
    (setq doom-modeline-env-enable-go t)
    (setq doom-modeline-env-enable-elixir t)
    (setq doom-modeline-env-enable-rust t)
    (setq doom-modeline-env-python-executable "python")
    (setq doom-modeline-env-ruby-executable "ruby")
    (setq doom-modeline-env-perl-executable "perl")
    (setq doom-modeline-env-go-executable "go")
    (setq doom-modeline-env-elixir-executable "iex")
    (setq doom-modeline-env-rust-executable "rustc")
    (setq doom-modeline-mu4e t)
    (setq doom-modeline-irc t)
    (setq doom-modeline-irc-stylize 'identity))
  (doom-modeline-mode 1)
#+end_src
* Utilities
There a lot of usefull packages, and they work excellent out of the box. 
** Which key
A helper to remember keybindings. If I wait a moment, a mini-buffer appears with some keybindings after I press a keychord.ni
#+begin_src emacs-lisp
  (use-package which-key
    :ensure t
    :init
    (which-key-mode))
#+end_src

** Magit
The best client for git, only on Emacs.
#+begin_src emacs-lisp
  (use-package magit
    :ensure t
    :config
    (global-set-key (kbd "C-x C-g") 'magit))
#+end_src

** Rainbow mode
If an hexagesimal color is on screen, you can see the actual color as the background of the string.
#+begin_src emacs-lisp
  (use-package rainbow-mode
    :ensure t
    :config
    (rainbow-mode 1))
#+end_src

** Smart parents
Autocomplete parenthesis. If you type the left parenthesis, the right one appears automatically. On elisp it's a need.
#+begin_src emacs-lisp
  (use-package smartparens
    :ensure t
    :config
    (smartparens-mode t))
#+end_src

** Rainbow delimiters
Parenthesis are colored, so it's easy to identify matching parenthesis.
#+begin_src emacs-lisp
  (use-package smartparens
    :ensure t
    :config
    (smartparens-mode t))
#+end_src

** Lua support
I don't code too much LUA, but it's good to have, at least, color syntax.
#+begin_src emacs-lisp
  (use-package lua-mode
    :ensure t)

  (use-package luarocks
    :ensure t)
#+end_src
** TODO Company
It's supossed to add completion, but does nothing.
#+begin_src emacs-lisp
  (use-package company
    :ensure t
    :config
    (company-mode 1))
#+end_src
** Ripgrep
Like ~grep~, but cooler. It needs ~ripgrep~ installed.
#+begin_src emacs-lisp
  (use-package rg
    :ensure t)
#+end_src
** Writeroom-mode
   When enabled, the text it's centered and the modeline disappears. Excellent to long writing sessions.
 #+begin_src emacs-lisp
 (use-package writeroom-mode
     :ensure t
     :bind ("<f6>" . writeroom-mode))
 #+end_src
* Ivy
~Ivy~ it's a completion framework. I preffer it over ~helm~ since is lighter, faster and looks better. And of course, it's a lot better than the default completion of Emacs, ido.
#+begin_src emacs-lisp
  (use-package ivy
    :ensure t
    :config
    (setq ivy-use-virtual-buffers t
	  ivy-count-format "%d/%d ")
    (setq ivy-re-builders-alist '((swiper . ivy--regex-plus)
				  (t . ivy--regex-fuzzy)))
    (setq ivy-extra-directories nil)
    (ivy-mode 1))
#+end_src

~ivy-rich~ adds some extra functionality. My favorite: a description of the command right on the minibuffer.
#+begin_src emacs-lisp
  (use-package ivy-rich 
    :ensure t
    :config
    (ivy-rich-mode 1))
#+end_src

~ivy-prescient~ adds a sort of history to ~ivy~, so it remembers my latest commands.
#+begin_src emacs-lisp
  (use-package ivy-prescient
    :ensure t
    :config
    (prescient-persist-mode 1)
    (ivy-prescient-mode 1))
#+end_src

** Counsel
~counsel~ adds some fixes to the search mechanism of Emacs. It's necesary for some packages and replaces some default commands like ~M-x~.
#+begin_src emacs-lisp
  (use-package counsel
    :ensure t
    :bind (
	   ("M-x" . counsel-M-x)
	   ("C-x C-f" . counsel-find-file))
    :config
    (define-key ivy-minibuffer-map (kbd "C-j") #'ivy-immediate-done)
    (define-key ivy-minibuffer-map (kbd "RET") #'ivy-alt-done)
    (counsel-mode 1))
#+end_src

** Swiper
A searching tool. It uses counsel and ivy. It adds a minibuffer with the matching results.
#+begin_src emacs-lisp
  (use-package swiper
    :ensure t
    :bind (("C-s" . swiper)))
#+end_src
* Yasnippet
Snippets are templates that are called interactively. I can write my own snippets.
#+begin_src emacs-lisp
  (use-package yasnippet
    :ensure t
    :config
    (yas-global-mode))
#+end_src

* Projectile
#+begin_src emacs-lisp
  (use-package projectile
    :ensure t)
#+end_src
* Dashboard
#+begin_src emacs-lisp
  (use-package dashboard
    :ensure t
    :config
    (dashboard-setup-startup-hook)
    (setq initial-buffer-choice (lambda () (get-buffer "*dashboard*")))
    (setq dashboard-banner-logo-title "Welcome to Emacs")
    (setq dashboard-startup-banner 'logo)
    (setq dashboard-show-shortcuts nil)
    (setq dashboard-set-init-info nil)
    (setq dashboard-items '(
			    (bookmarks . 5)
			    (projects . 5)
			    (agenda . 5)))
    (setq dashboard-center-content t)
    (setq dashboard-page-separator "\n\n")
    (setq dashboard-set-heading-icons t)
    (setq dashboard-set-file-icons t)
    )
#+end_src
* Themes
  Emacs has a lot of themes available on internet. It's possible to set one with ~(load-theme)~. Check the ~heaven&hell~ package below.
  
** Doom-themes
A collection of themes designated for ~doom-emacs~.
#+begin_src emacs-lisp
  (use-package doom-themes
    :ensure t
    :config
    (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
	  doom-themes-enable-italic t) ; if nil, italics is universally disabled
    (doom-themes-visual-bell-config)
    (doom-themes-neotree-config)
    (doom-themes-treemacs-config)
    (doom-themes-org-config))
#+end_src

** Modus theme
   The famous modus themes by Protesilaos Stavrou. Sadly, I can't stand the dark theme. Too dark for my taste.
 #+begin_src emacs-lisp
   (use-package modus-vivendi-theme
     :ensure t)
   (use-package modus-operandi-theme
     :ensure t
     :config
     (setq modus-operandi-theme-slanted-constructs t)
     (setq modus-operandi-theme-syntax 'alt-syntax))
 #+end_src

* Heaven and Hell
This packages allow to quicky change between two themes. The recommended setup, a light and a dark theme.
#+begin_src emacs-lisp
  (use-package heaven-and-hell
    :ensure t
    :init
    (setq heaven-and-hell-theme-type 'dark)
    (setq heaven-and-hell-load-theme-no-confirm t)
    (setq heaven-and-hell-themes
	  '((light . doom-one-light)
	    (dark . doom-one)))
    :hook (after-init . heaven-and-hell-init-hook)
    :bind (("C-c <f7>" . heaven-and-hell-load-default-theme)
	   ("<f7>" . heaven-and-hell-toggle-theme)))
#+end_src

* Markdown
  Though I don't use markdown a lot on Emacs, it's fine to have syntax highlightning and some functionality with ~pandoc~. It needs ~pandoc~ installed. If you're on arch and you doesn't work with Haskell, download ~pandoc-bin~ from AUR and evade the +750Mb of haskell libraries.

#+begin_src emacs-lisp
  (use-package markdown-mode
    :ensure t
    :mode (("README\\.md\\'" . gfm-mode)
	   ("\\.md\\'" . markdown-mode)
	   ("\\.markdown\\'" . markdown-mode))
    :init (setq markdown-command "multimarkdown"))
  (setq markdown-command "/usr/bin/pandoc")
#+end_src

* Dired
~Dired~ it's the Emacs buit-in file manager. Dired it's awesome, it does a lot out of the box liike compress, copy, move ("rename" in dired language), delete, and of course, edit files. There's some extensions to add more functionality, so you can have a very powerfull file manager, even better than ~ranger~, ~nnn~ or ~lf~.

Dired it's a hard topic to me. I really want to like it, and really I try. The main problem is, though dired is awesome inside Emacs, maybe you'll have problems trying to open files externally, let's say videos or LibreOffice files. Right now, I think I have a good setup and I can use it, but I'm not sure how many time it'll take until I return to ~lf~...

But lets configure this thing!
#+begin_src emacs-lisp
    (use-package dired
      :ensure nil ; it's a built-in package
      :commands (dired dired-jump)
      :bind (("C-x C-j" . dired-jump) ; To quickly open a dired buffer on the file path
	     ("C-<return>" . (lambda () (interactive) (shell-command "alacritty > /dev/null 2>&1 & disown")))) ; To quickly open a Terminal window
      :hook (
	     (dired-mode . dired-hide-details-mode)
	     (dired-mode . hl-line-mode))
      :config
      (setq dired-listing-switches "-AgGhovF --group-directories-first") ; man ls to details
      (setq dired-recursive-copies 'always)
      (setq dired-recursive-deletes 'always)
      (setq delete-by-moving-to-trash t) ;It uses the trash bin
      (setq dired-dwim-target 'dired-dwim-target-next-visible) ; If I have two buffers or frames open and I try to copy a file from one buffer, it understand that I want to copy it to the other buffer.

      ;; Some keybindings. It makes use of the ~evil-collection~ key-map and (maybe) replaces some default keybindings.
      (evil-collection-define-key 'normal 'dired-mode-map
	"h" 'dired-single-up-directory
	"l" 'dired-open-file
	"nd" 'dired-create-directory
	"nf" 'dired-create-empty-file
	"/" 'swiper
	"gj" 'counsel-bookmark))
#+end_src

By default dired creates a new buffer for every directory open. This will create a mess of buffers with a lot of dired buffers open. This packages try to avoid this, but dired still creates some buffers. 
#+begin_src emacs-lisp
  (use-package dired-single
    :ensure t)
#+end_src

As I said before, the integration with external tools can be improved. This package tries to do that. The main problem with this is you need to specify the extension, so this list it'll be huge very easily. There's a variable to use ~xdg-open~ instead but it has problems. If only I could use mime types instead.

#+begin_src emacs-lisp
  (use-package dired-open
    :ensure t
    :config
    (setq dired-open-extensions '(
				  ;; Images
				  ("png" . "rifle_sxiv.sh")
				  ("jpg" . "rifle_sxiv.sh")
				  ;; Multimedia
				  ("mp4" . "mpv")
				  ("mkv" . "mpv")
				  ("mp3" . "mpv")
				  ("aac" . "mpv")
				  ("ogg" . "mpv")
				  ("avi" . "mpv")
				  ("mov" . "mpv")
				  ("flac" . "mpv")
				  ;; libreoffice
				  ("odt" . "libreoffice")
				  ("odf" . "libreoffice")
				  ("ods" . "libreoffice")
				  ("odp" . "libreoffice")
				  ;; Otros
				  ("pdf" . "zathura")
				  )))
#+end_src

Dired shows your dotfiles or it doesn't. This packages allows to toggle the directories that starts with a period. I added a keybinding to toggle it.

#+begin_src emacs-lisp
  (use-package dired-hide-dotfiles
    :ensure t
    :hook (dired-mode . dired-hide-dotfiles-mode)
    :config
    (evil-collection-define-key 'normal 'dired-mode-map
      "zh" 'dired-hide-dotfiles-mode))
#+end_src

This is an interesting package. It adds a tree layout to dired, so I can navigate directories in a similar fashion to ~org-mode~.
#+begin_src emacs-lisp
  (use-package dired-subtree
    :ensure t
    :config
    (setq dired-subtree-use-backgrounds nil)
    ;; this snippet adds icons from all-the-icons to the subtree
    (advice-add 'dired-subtree-toggle :after (lambda ()
					       (interactive)
					       (when all-the-icons-dired-mode
						 (revert-buffer)))))
#+end_src

This is needed to launch dired with a keybinding from my window manager
#+begin_src emacs-lisp
  (defun dired-frame ()
    (interactive)
    (dired)
    (delete-other-windows))
#+end_src
* All the icons
Cool icons! It adds icons to ~doom-modeline~, ~dired~ and ~ivy~. Remember to run ~all-the-icons-install-font~ to actually see the icons. 
#+begin_src emacs-lisp
  (use-package all-the-icons
    :ensure t)

  ;; Icons for dired
  (use-package all-the-icons-dired
    :ensure t
    :hook (dired-mode . (lambda ()
			  (interactive)
			  (unless (file-remote-p default-directory)
			    (all-the-icons-dired-mode)))))

  ;; Icons for ivy
  (use-package all-the-icons-ivy-rich
    :ensure t
    :init (all-the-icons-ivy-rich-mode 1))
#+end_src
* Easy Hugo
Run ~hugo~ commands from Emacs and administrate your blogs. It needs ~hugo~ installed and configured. Note that evil mode is disabled for ~easy-hugo~.
#+begin_src emacs-lisp
  (use-package easy-hugo
    :ensure t
    :init 
    ;;; Main blog. you can have more if you want
    (setq easy-hugo-basedir "/mnt/Data/Blog/")
    (setq easy-hugo-postdir "content/posts/")
    :config
    (add-to-list 'evil-emacs-state-modes 'easy-hugo-mode)
    (setq easy-hugo-default-ext ".org")
    (setq easy-hugo-org-header t))
#+end_src

* Ledger
Ledger it's a program to keep track of your expenses. It's very unix-y, it reads a text file with a very simple and human-readable format and prints out information about your balance. This is a mode to easily write the transactions and run ledger directly from Emacs.

#+begin_src emacs-lisp
  (use-package ledger-mode
    :ensure t
    :config
    (evil-define-key 'normal ledger-mode-map (kbd "SPC r") 'ledger-report)
    (evil-define-key 'normal ledger-mode-map (kbd "SPC i") 'ledger-add-transaction))

  (use-package evil-ledger
    :ensure t
    :after ledger-mode
    :hook
    (ledger-mode . evil-ledger-mode))
#+end_src

#+RESULTS:
| evil-ledger-mode |


* Org-mode
The killer feature of Emacs and the reason why I started to use Emacs. Org-mode it's a note taking and schedulling format with some markup capabilities. This "markup" it's more powerful than any other. You can create tables, spreadsheets, run code (just see this config file), export to a lot of formats, the integration with LaTeX it's awesome, and there's a lot of plugins and packages to extend it. If you want an idea of the potential of org-mode, my thesis was written almost entirely on org-mode with cites, bibliography, images, tables and everything else; just the final design (fonts, colors and things like that) was made with LibreOffice, and that's beacause I didn't knew a lot of LaTeX back then.

I pass most of the time on org-mode. Since I'm not a developer it takes the place of word processors, simple spreadsheets and any calendar and /todo/ application. SO this section it'll be long, but the most important to me.

** org-mode configuration
Here's some configuration I made to org-mode, the actual package.
#+begin_src emacs-lisp
  (use-package org
    :ensure nil
    :hook
    (org-mode . variable-pitch-mode)
    :config
    ;; Removes the ellipsis at the end and replaces it with a string
    (setq org-ellipsis " ●")

    ;; If you have many subtask, when you mark it as DONE, the main task remain unchaged. With this function, if all the subtask are marked as DONE, the main task is marked as well.
    (defun org-summary-todo (n-done n-not-done)
      "Switch entry to DONE when all subentries are done, to TODO otherwise."
      (let (org-log-done org-log-states)   ; turn off logging
	(org-todo (if (= n-not-done 0) "DONE" "PROJ"))))
    (add-hook 'org-after-todo-statistics-hook 'org-summary-todo)
    ;; This keybinding uses org-store-link to store a postition on a document, so you can link it on other document.
    (global-set-key (kbd "C-c l") 'org-store-link)

    ;; Change TODO states with SPC t. It uses evil-collection key-map.
    (evil-define-key 'normal org-mode-map
      (kbd "SPC t") 'org-todo)

    ;; You can add blocks pressing C-, and then the corresponding key.
  (require 'org-tempo)
  (setq org-structure-template-alist
     '(("el" . "src emacs-lisp")
       ("a" . "export ascii")
       ("c" . "center")
       ("C" . "comment")
       ("e" . "example")
       ("E" . "export")
       ("h" . "export html")
       ("x" . "export latex")
       ("q" . "quote")
       ("s" . "src")
       ("v" . "verse"))))
#+end_src
** Fonts
It's possible to mix monospace fonts with variable-spaced fonts. To activate this behaviour, enable ~variable-pitch-mode~. This uses the fonts declared at the beggining of the document.
#+begin_src emacs-lisp
  (set-face-attribute 'org-block nil :foreground nil :inherit 'fixed-pitch)
  (set-face-attribute 'org-code nil :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-table nil :inherit '(shadow fixed-pitch))
  ;(set-face-attribute 'org-indent nil :inherit '(org-hide fixed-pitch))
  (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
  (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
  (set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch)


#+end_src

Now, let's make a more elegant style, without colors for title and with different sizes.
#+begin_src emacs-lisp
  ;;; Titles and Sections
  (setq org-hidden-keywords '(title))
  ;; set basic title font
  (set-face-attribute 'org-level-8 nil :weight 'bold :inherit 'default)
  ;; Low levels are unimportant => no scaling
  (set-face-attribute 'org-level-7 nil :inherit 'org-level-8)
  (set-face-attribute 'org-level-6 nil :inherit 'org-level-8)
  (set-face-attribute 'org-level-5 nil :inherit 'org-level-8)
  (set-face-attribute 'org-level-4 nil :inherit 'org-level-8)
  ;; Top ones get scaled the same as in LaTeX (\large, \Large, \LARGE)
  (set-face-attribute 'org-level-3 nil :inherit 'org-level-8 :height 1.1) ;\large
  (set-face-attribute 'org-level-2 nil :inherit 'org-level-8 :height 1.3) ;\Large
  (set-face-attribute 'org-level-1 nil :inherit 'org-level-8 :height 1.5) ;\LARGE
  ;; Only use the first 4 styles and do not cycle.
  (setq org-cycle-level-faces nil)
  (setq org-n-level-faces 4)
  ;; Document Title, (\huge)
  (set-face-attribute 'org-document-title nil
		      :height 2.074
		      :foreground 'unspecified
		      :inherit 'org-level-8)
#+end_src
** More export formats
Though org-mode has a long range of formats, we can add more.
#+begin_src emacs-lisp
  ;; Pandoc support
  (use-package ox-pandoc
    :ensure t)

  ;; LaTeX beamer support
  (org-beamer-mode)
#+end_src
** Superstar
It replaces the stars for bullets and unicode glyphs. It looks nice and it's easier to read. Also, changes some TODO keywords.
#+begin_src emacs-lisp
    (use-package org-superstar
      :ensure t
      :config
      (setq superstar-special-todo-items t))

    (defun my/org-enable-prettify ()
      (setq prettify-symbols-alist
	    '(("TODO" . ?❗)
	      ("DONE" . ?✔)
	      ("PROJ" . ?✎)
	      ("WAIT" . ?⌛)
	      ("NEXT" . ?➠)
	      ("EVENTO" . ?)
	      ("DROP" . ?✖)
	      ("EMISION" . ?✒)
	      ("FINALIZADO" . ?✔)
	      ("LIKE" . ?❤)
	      ("CANCELADO" . ?✘)))
      (prettify-symbols-mode 1))
    (add-hook 'org-mode-hook 'my/org-enable-prettify)
  
   ;; This hook enables org-superstar 
    (add-hook 'org-mode-hook
	      (lambda ()
		(org-superstar-mode 1)))
#+end_src
** Org-tree-slide
Want to make a presentation with slides but don't want to use PowerPoint, beamer or some ridiculous web-based slides? Just use Emacs and org-mode to show your slides. The slides are, basically, narrowed org buffers, so they're editable and you can use the complete power of org-mode and Emacs.
#+begin_src emacs-lisp
  (use-package org-tree-slide
    :ensure t
    :config
    (setq org-tree-slide-header nil)
    (setq org-tree-slide-slide-in-effect nil)
    )

  ;; This packages hides the modeline because I don't know how to hide it without it.
  (use-package hide-mode-line
    :ensure t)

  ;; This keys are to go to the next or previous slide. It uses ~evil-collection key-map
  (evil-define-key 'normal 'org-tree-slide-mode-map
    "{"  'org-tree-slide-move-previous-tree
    "}"  'org-tree-slide-move-next-tree)
#+end_src

When showing your slides you want to remove all distractions right? This hooks do it.
#+begin_src emacs-lisp
  (eval-after-load "org-tree-slide"
    '(progn
       (add-hook 'org-tree-slide-play-hook
		 (lambda ()
		   (org-display-inline-images 1)
		   (hide-mode-line-mode 1)
		   (display-line-numbers-mode -1)
		   (variable-pitch-mode 1)))
       (add-hook 'org-tree-slide-stop-hook
		 (lambda ()
		   (org-display-inline-images -1)
		   (hide-mode-line-mode -1)
		   (display-line-numbers-mode 1)
		   (variable-pitch-mode -1)))))
#+end_src
** Agenda
Org-mode is a TODO and scheduling format. So it has an integrated agenda. You can configure it and make it looks like you want it.

Let's define some basic stuff first
#+begin_src emacs-lisp
    (setq org-directory "/mnt/Data/ORG") ; The directory of your files
    (setq org-agenda-files '("/mnt/Data/ORG/TODO.org"))
    (global-set-key (kbd "C-c a") 'org-agenda) ; Keybinding to open the agenda buffer

    ;; by default the agenda takes the current buffer. With this it'll create its own buffer
    (setq org-agenda-window-setup 'other-window)
    (setq org-agenda-span 3) ; Only shows next 3 days
    (setq org-agenda-start-on-weekday nil) ;;Agenda start on monday
    (setq org-agenda-start-with-log-mode t)
    (setq org-log-done 'time)
    (setq org-log-into-drawer t)

    ;; Since I speak spanish as my mother language, I want the days and months in spanish. Without this it'll remain on english.
    (setq calendar-day-name-array ["domingo" "lunes" "martes" "miércoles" "jueves" "viernes" "sábado"])
    (setq calendar-month-name-array ["enero" "febrero" "marzo" "abril" "mayo" "junio" "julio" "agosto" "septiembre" "octubre" "noviembre" "diciembre"])
  
    ;; Activate hl-line-mode on agenda buffers
    (add-hook 'org-agenda-mode-hook 'hl-line-mode)
#+end_src

Now, this is pure eye-candy
#+begin_src emacs-lisp
  ;; Removes the ~======~ between blocks. It's ugly IMO
  (setq org-agenda-block-separator (string-to-char " "))

  ;;Remove ths strings ~SCHEDULED:~ and ~DEADLINE:~ 
  (setq org-agenda-scheduled-leaders '(" " " "))
  (setq org-agenda-deadline-leaders '(" " "En %d días: " "Hace %d días: "))

  ;; Custom fonts! I'm using Ubuntu fonts here... I'm not sure why.
  (custom-theme-set-faces 'user
			    '(org-agenda-date-today ((t (:weight ultra-bold :height 130 :family "Ubuntu")))) ; Today
			    '(org-agenda-structure ((t (:underline t :weight bold :height 200 :width normal :family "Ubuntu")))) ; Titles
			    '(org-agenda-calendar-event ((t (:family "Ubuntu" :inherit (default))))));Rest of the text
#+end_src


This is my own agenda. It has the modules I want, the way I want. To run it, press ~o~.
#+begin_src emacs-lisp
  (setq org-agenda-custom-commands
	'(("o" "My Agenda"
	   ((todo "TODO" (
			  (org-agenda-overriding-header " Tareas:\n")
			  (tags-todo "TODO")
			  (org-agenda-remove-tags t)
			  (org-agenda-prefix-format "%T %?-s")
			  (org-agenda-todo-keyword-format "")))
	    (agenda "" (
			(org-agenda-overriding-header "  Eventos:\n")
			(org-agenda-skip-scheduled-if-done t)
			(org-agenda-skip-timestamp-if-done t)
			(org-agenda-skip-deadline-if-done t)
			(org-agenda-skip-deadline-prewarning-if-scheduled t)
			(org-agenda-start-day "+0d")
			(org-agenda-span 3)
			(org-agenda-prefix-format "  %?-t %T %?-5s")
			(org-agenda-repeating-timestamp-show-all nil)
			(org-agenda-remove-tags t)
			;;(concat "  %-3i  %-15b %t%s" org-agenda-hidden-separator))
)
		    (org-agenda-todo-keyword-format " -> ")
		    (org-agenda-time)
		    (org-agenda-current-time-string "⮜┈┈┈┈┈┈┈ ahora")
		    (org-agenda-deadline-leaders '("" ""))
		    (org-agenda-time-grid (quote ((today require-timed) (800 1000 1200 1400 1600 1800 2000 2200) "      " "┈┈┈┈┈┈┈┈┈┈┈┈┈"))))
	    ))))
#+end_src

Finally, this function it's needed to spawn a floating agenda with my Window Manger
#+begin_src emacs-lisp
  (defun agenda-frame ()
    (interactive)
    (org-agenda nil "o")
    (delete-other-windows))
#+end_src

** calfw
   Org-agenda shows your entries as a list. If you want a calendar view, then you need to rely on this awesome package called ~calfw~. To run it, run ~cfw:open-calendar-buffer~ or ~cfw:open-org-calendar~. 
   #+begin_src emacs-lisp
     (use-package calfw
       :ensure t)
     (use-package calfw-org
       :ensure t)
   #+end_src
*** Org-capture
    Org-capture allows to capture text at any moment, just call the buffer, write text and automatically it will be appended to the selected file. This are my templates.
 #+begin_src emacs-lisp
   (global-set-key (kbd "C-c c") 'org-capture)
   (setq org-capture-templates
	 '(
	   ("t" "Entradas del trabajo")
	   ("tt" "TODO" entry
	    (file "~/mnt/DATA/ORG/Trabajo.org")
	    "* TODO %?\n%u" :prepend t)
	   ("ta" "Agenda"  entry
	    (file "~/mnt/DATA/ORG/Trabajo.org")
	    "* %?\n SCHEDULED: %t")
	   ("p" "Entradas personales")
	   ("pt" "TODO" entry
	    (file "~/mnt/DATA/ORG/Trabajo.org")
	    "* TODO %?\n%u" :prepend t)
	   ("pa" "Agenda"  entry
	    (file "~/mnt/DATA/ORG/Trabajo.org")
	    "* %?\n SCHEDULED: %t")))
 #+end_src
   
 It's possible to call org-capture from anywhere using the Window Manager. To have a floating window, this snippet its needed
 #+begin_src emacs-lisp
   ;; Org capture flotante
   (defadvice org-capture-finalize
   (after delete-capture-frame activate)
   "Advise capture-finalize to close the frame"
   (if (equal "capture" (frame-parameter nil 'name))
   (delete-frame)))

   (defadvice org-capture-destroy
   (after delete-capture-frame activate)
   "Advise capture-destroy to close the frame"
   (if (equal "capture" (frame-parameter nil 'name))
   (delete-frame)))
 #+end_src
*** LaTeX
    LaTeX uses some templates to define classes. You can write your own classes. I have this, one used on my thesis, the other copied from the org-wiki because it looks nice.
 #+begin_src emacs-lisp
   (add-to-list 'org-latex-classes
	 '("koma-article"
	   "\\documentclass{scrartcl}"
	   ("\\section{%s}" . "\\section*{%s}")
	   ("\\subsection{%s}" . "\\subsection*{%s}")
	   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
	   ("\\paragraph{%s}" . "\\paragraph*{%s}")
	   ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))
	
	 '("doc-recepcional"
	   "\\documentclass{report}"
	   ("\\chapter{%s}" . "\\chapter*{%s}")
	   ("\\section{%s}" . "\\section*{%s}")
	   ("\\subsection{%s}" . "\\subsection*{%s}")
	   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
	   ("\\paragraph{%s}" . "\\paragraph*{%s}")
	   ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
 #+end_src
** org babel
   Org-babel allows to run code inside Emacs and print the output right after the code block. Babel it's used to create this config file. You need the required compilers and everything if you add more languages here. By default, babel only evaluates elisp.
 #+begin_src emacs-lisp
   (org-babel-do-load-languages
    'org-babel-load-languages
    '((python . t)
      (shell . t)))
 #+end_src
* TODO set font for emoji
* Eshell
#+begin_src emacs-lisp
  (use-package eshell-git-prompt
    :ensure t)
    (use-package fish-completion
    :ensure t
  :hook (eshell-mode . fish-completion-mode))
  
  (use-package eshell-syntax-highlighting
  :ensure t
  :after esh-mode
  :config
  (eshell-syntax-highlighting-global-mode +1))
  
(use-package esh-autosuggest
:ensure t
  :hook (eshell-mode . esh-autosuggest-mode)
  :config
  (setq esh-autosuggest-delay 0.5)
  (set-face-foreground 'company-preview-common "#4b5668")
  (set-face-background 'company-preview nil))

  (use-package eshell-toggle
  :ensure t
  :bind ("<f4>" . eshell-toggle)
  :custom
  (eshell-toggle-size-fraction 3)
  (eshell-toggle-use-projectile-root t)
  (eshell-toggle-run-command nil))

#+end_src

